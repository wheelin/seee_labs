/*******************************************************************
 * reptar_sp6.c
 *
 * Author: Romain Bornet (RBO), Daniel Rossier (DRE)
 * Copyright (c) 2013 HEIG-VD, REDS Institute
 *******************************************************************/

#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/firmware.h>
#include <linux/interrupt.h>
#include <linux/input.h>

#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/platform_device.h>
#include <linux/gpio.h>

#include <asm/uaccess.h>

#include "reptar_sp6.h"

#define FPGA_BASE 0x18000000

/* BOARD SPECIFIC CODE */
static struct resource fpga_resources[] = {
		{
		  .name = "fpga",
		  .start = FPGA_BASE,
		  .end = FPGA_BASE + 0xffff,
		  .flags = IORESOURCE_MEM
		},
		{
		  .name = "fpga_irq_gpio",
		  .start = 10,
		  .end = 10,
		  .flags = IORESOURCE_IRQ
		}
};

/* Additional platform data related to FPGA */
struct fpga_platform_data {
	struct class *fpga_class;
} fpga_pdata;

static struct platform_device *fpga;

/* LEDS */
struct reptar_sp6_led_platdata reptar_sp6_leds_pdata[] = {
	{
		.name		= "sp6_led0",
		.bit		= 0,
		.reg_offset = 0x3a
	},
	{
		.name		= "sp6_led1",
		.bit		= 1,
		.reg_offset = 0x3a
	},
	{
		.name		= "sp6_led2",
		.bit		= 2,
		.reg_offset = 0x3a
	},
	{
		.name		= "sp6_led3",
		.bit		= 3,
		.reg_offset = 0x3a
	},
	{
		.name		= "sp6_led4",
		.bit		= 4,
		.reg_offset = 0x3a
	},
	{
		.name		= "sp6_led5",
		.bit		= 5,
		.reg_offset = 0x3a
	},
};

/* Buttons */
struct reptar_sp6_buttons_platdata reptar_sp6_btns_pdata = {
	.btns_reg_offset = 0x12,
	.irq_reg_offset = 0x18,

	/* Key codes generated by buttons 0 --> 7 */
	.keys = {KEY_UP, KEY_LEFT, KEY_DOWN, KEY_RIGHT, KEY_ENTER, KEY_ESC, KEY_SPACE, KEY_BACKSPACE},
};

/* < END OF BOARD SPECIFIC CODE > */

/* FPGA Bitstream version */
static char bitstream_version[80] = "FPGA bitstream VERSION";

/* Callbacks for char device */

ssize_t fpga_read(struct file *filp, char *buffer, size_t length, loff_t *offset) {

	/* If offset is not zero, it means that a previous read already occured.
	* So, we tell the user space that we are at the end
	*/
	
	if (*offset != 0)
		return 0;
	if(copy_to_user(buffer, bitstream_version, sizeof(bitstream_version)) != 0)
	{
		return -EFAULT;
	}
	return sizeof(bitstream_version);			
}

ssize_t fpga_write(struct file *filp, const char *buff, 
					size_t len, loff_t *off) {
	if(len > 80)
		return -EFAULT;

	if(copy_from_user(bitstream_version, buff, len) != 0)
		return -EFAULT;
	return len;
}

struct file_operations fpga_fops = {
  .read = fpga_read,
  .write = fpga_write,
};

/* FPGA driver probe */
static int fpga_probe(struct platform_device *pdev) {
  int ret;
  struct fpga_platform_data *pdata;
  struct cdev *fpga_cdev;

  printk("Probing FPGA driver (device: %s)\n", pdev->name);

  pdata = pdev->dev.platform_data;

  /* Nice to use platform_data in dev field to transport private info...*/
  pdata->fpga_class = class_create(THIS_MODULE, "fpga");

  /* character device ... */
  ret = alloc_chrdev_region(&pdev->dev.devt, 0, 1, "fpga");
  if (ret) {
    printk("%s alloc_chrdev failed!\n", __FUNCTION__);
    return -1;
  }

  fpga_cdev = cdev_alloc();

  /* We store the newly allocated cdev as a private driver data to this device */
  dev_set_drvdata(&pdev->dev, fpga_cdev);

  /* Initializing character device to enable user space ops */
  cdev_init(fpga_cdev, &fpga_fops);
  cdev_add(fpga_cdev, pdev->dev.devt, 1);

  device_create(pdata->fpga_class, NULL, pdev->dev.devt, NULL, "sp6");

  return 0;
}

static int fpga_remove(struct platform_device *pdev) {
	struct fpga_platform_data *pdata;
	struct cdev *fpga_cdev;

	fpga_cdev = dev_get_drvdata(&pdev->dev);
	pdata = pdev->dev.platform_data;

	cdev_del(fpga_cdev);
	device_destroy(pdata->fpga_class, pdev->dev.devt);
	unregister_chrdev_region(pdev->dev.devt, 1);
	
	return 0;
}

static struct platform_driver fpga_drv = {
		.probe = fpga_probe,
		.remove = fpga_remove,
		.driver = {
		  .name = "fpga",
		  .owner = THIS_MODULE,
		},
};

static int __devinit reptar_sp6_init(void) {

  int ret;

  printk("reptar_sp6: module starting...\n");

  fpga = platform_device_alloc("fpga", -1);

  if (!fpga) {
	  printk("%s failed to alloc platform device\n", __FUNCTION__);
	  return -ENOMEM;
  }

  ret = platform_device_add_resources(fpga, fpga_resources, ARRAY_SIZE(fpga_resources));

  if (ret) {
	printk("%s failed to add resources to platform device\n", __FUNCTION__);
    return -ENOMEM;
  }

  ret = platform_device_add_data(fpga, &fpga_pdata, sizeof(fpga_pdata));

   if (ret) {
         printk("%s failed to add data to platform device\n", __FUNCTION__);
     return -ENOMEM;
   }

  ret = platform_device_add(fpga);

  if (ret) {
	printk("%s failed to add data to platform device\n", __FUNCTION__);
    return -ENOMEM;
  }

  platform_driver_register(&fpga_drv);

  reptar_sp6_leds_init(fpga);
  reptar_sp6_buttons_init(fpga);

  printk("reptar_sp6: done.\n");

  return 0;
}

static void __exit reptar_sp6_exit(void) {

	struct fpga_platform_data *pdata;
	pdata = fpga->dev.platform_data;
    
	reptar_sp6_buttons_exit();
	reptar_sp6_leds_exit();

	platform_device_unregister(fpga);
	class_destroy(pdata->fpga_class);
	platform_driver_unregister(&fpga_drv);

	printk("reptar_sp6: bye bye!\n");
}

module_init(reptar_sp6_init);
module_exit(reptar_sp6_exit);

MODULE_LICENSE("GPL");
